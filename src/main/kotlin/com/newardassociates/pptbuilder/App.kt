/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.newardassociates.pptbuilder

import com.newardassociates.pptbuilder.nop.NOPProcessor
import com.newardassociates.pptbuilder.pptx.PPTXProcessor
import com.newardassociates.pptbuilder.reveal.RevealProcessor
import com.newardassociates.pptbuilder.slidy.SlidyProcessor
import com.newardassociates.pptbuilder.text.TextProcessor
import kotlinx.cli.*
import java.io.File
import java.io.FileInputStream
import java.net.URL
import java.util.*
import java.util.jar.Attributes
import java.util.jar.JarFile
import java.util.jar.Manifest
import java.util.logging.*
import java.util.logging.Formatter

class TerseFormatter : Formatter() {
    override fun format(record: LogRecord?): String {
        return "${record!!.level}: ${formatMessage(record)}\n"
    }
}

fun getBuildTimestamp() : String {
    val clazz: Class<*> = Parser::class.java
    val jarFile = JarFile(File(clazz.protectionDomain.codeSource.location.toURI()).path)
    val manifest = jarFile.manifest
    val attributes = manifest.mainAttributes
    return attributes.getValue("Build-Timestamp")
}

fun main(args: Array<String>) {
    println("pptbuilder v0.9 (Build-Timestamp: ${getBuildTimestamp()})")
    println("---------------------------------------------")
    val cliParser = ArgParser("pptbuilder")

    val input by cliParser.argument(ArgType.String, description = "Input file")
    val output by cliParser.argument(ArgType.String, description = "Output file name").optional()

    val outputDirectory by cliParser.option(ArgType.String, 
            fullName = "outputDir", shortName = "d",
            description = "Output directory into which to place the generated file").default("")

    val verbosity by cliParser.option(ArgType.Choice(listOf("quiet", "warning", "info", "debug"), { it }),
            fullName = "verbosity", shortName = "v",
            description = "How much logging to display").default("warning")
    val logfile by cliParser.option(ArgType.String,
            fullName = "logfile", shortName = "l",
            description = "The filename to capture logging to").default("")

    val format by cliParser.option(ArgType.Choice(listOf("pptx", "reveal", "slidy", "text", "nop"), { it }),
            fullName = "format", shortName = "f",
            description = "Output format to use").default("pptx")
    val template by cliParser.option(ArgType.String,
            fullName = "template", shortName = "t",
            description = "The processing template file to use to start from (pptx only)").default("")

    cliParser.parse(args)

    // Turn off default ConsoleHandler
    LogManager.getLogManager().reset()
    Logger.getLogger(java.util.logging.Logger.GLOBAL_LOGGER_NAME).level = java.util.logging.Level.OFF    
    // Configure LogManager according to verbosity flag
    val logger = Logger.getLogger(::main.javaClass.packageName)
    logger.level = when (verbosity) {
        "quiet" -> Level.SEVERE
        "info" -> Level.INFO
        "debug" -> Level.ALL
        else -> Level.WARNING
    }
    val handler = when (logfile) {
        "" -> ConsoleHandler()
        else -> FileHandler(logfile)
    }
    handler.formatter = TerseFormatter()
    logger.addHandler(handler)
    println("Configuring ${logger.name} logging at ${logger.level} levels...")

    // Grab default properties from .pptbuilder.properties
    val properties = Properties()
    val propertiesFile = "${System.getProperty("user.home")}/.pptbuilder.properties"
    if (File(propertiesFile).exists())
        properties.load(FileInputStream(propertiesFile))
    //println("... using properties from ${propertiesFile}: $properties")

    // Design thought:
    // Does it make more sense to import the CLI args into the properties, and then
    // pull the values out of there, rather than what I'm doing here?

    val inputPath = File(input).path
    val inputFile = File(input).name

    val outputPath = if (outputDirectory != "") outputDirectory else (properties["outputPath"] ?: ".").toString() + "/"
    val outputFile = if (output != null) output else inputFile.substringBeforeLast(".")

    val templateFile = (if (template != "") template else (properties["template"] ?: "")).toString()

    //println("... parsing ${inputPath}/${inputFile} to ${outputPath}${outputFile}${if (templateFile != "") " using ${templateFile}..." else ""}...")

    /*
        val outputFilename : String = "",
        val templateFile : String = "",
        val baseDirectory : String = "",
        val noTitleSlide : Boolean = false,
        val noNotesSlides : Boolean = false
     */
    val processorOptions = Processor.Options(
            outputFilename = outputPath + outputFile,
            templateFile = templateFile
    );

    // It's just too much fun to NOT do all of this in one compound expression
    (when (format) {
        //"ast" -> ASTProcessor(processorOptions)
        "nop" -> NOPProcessor(processorOptions)  // just for verifying input, don't generate output
        //"impress" -> ImpressProcessor(processorOptions)  // for HTML/impress.js
        "pptx" -> PPTXProcessor(processorOptions)
        "reveal" -> RevealProcessor(processorOptions)  // for HTML/reveal.js
        "slidy" -> SlidyProcessor(processorOptions)  // for HTML Slidy
        "text" -> TextProcessor(processorOptions)
        //"webslides" -> WebSlidesProcessor(processorOptions)  // for HTML WebSlides
        else -> throw IllegalArgumentException("Unrecognized format: ${format}")
    }).process(Parser(properties).parse(File(input)))
}
